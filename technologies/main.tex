\newpage
\ESKDthisStyle{formII}
\section{Выбор технологий}
\subsection{В начале работы}
\subsubsection{Использование языка PHP}
Первоначально в качестве языка программирования было решено использовать язык
PHP. Это было вызвано низким порогим вхождения, его большой популярности, а
следовательно большим наличием учебных материалов и примеров.

\subsubsection{Zend Framework}
В процессе работы возникла необходимость грамотной организации исходного кода,
использование тестов. Так в проект добавилась знаменитая среди разработчиков
библиотека Zend Framework. Эта библиотека решила вопрос с организацией кода
путем использования паттерна MVC - Model View Controller.

\subsubsection{Переход на платформу ASP.NET MVC}
В процессе разработки стали заметны недостатки Zend Framework: большая
избыточность кода (много абстракций вследствие данной реализации концепции MVC),
долгое время отклика, необходимость вручную составлять запросы, связывающие
модель предметной области с базой данных.

Было решено перенести проект на стек технологий от компании Microsoft. В
качестве базовой технологии была выбрана платформа  ASP.NET, язык
программирования C\#. В качестве организации кода решено было продолжить
использовать паттерн MVC.

\subsubsection{Большие затраты времени на конфигурирование}
Вместе с использованием ASP.NET, для доступа моделей предметной области к данным
был использован паттерн Repository. Однако это не решило вопрос с ручным
созданием объектов в базе данных. Таким образом  стало ясно, что без
использования технологии ORM не обойтись. С этой целью был использована
библиотека Entity Framework.

Несмотря на то что библиотека Entity Framework сильно облегчает и ускоряет
работу программиста, регламентирование доступа к базе данных из модели с помощью
паттерна Repository заставляет писать дополнительный программный код - помимо
перечисления атрибутов сущностей в классе, для каждого поля  необходимо
прописывать атрибуты используемые в процессе работы Entity Framework.

Еще одним минусом стало ручное прописывание валидационных правил и метаданных сущностей. 
Для организации их работы приходилось вручную прописывать все атрибуты, что вызывает 
неудобство и повышает вероятность ошибки.

\subsection{Выбор платформы Ruby on Rails}
\subsubsection{Регламентированный доступ к базе данных}
Для доступа к данным в Rails используется ORM c реализацией паттерна
ActiveRecord - шаблон проектирования приложений, описанный Мартином Фаулером.
Основная суть заключается в том, что для каждой таблице в БД создается
соответствующий ей класс, каждой строке в данной таблице соответствует экземпляр
соответствующего ей класса. Каждое действие с экземпром данного класса
(создание, изменение и удаление) сопровождается соответствующими SQL- запросом.

Запросы для выборки данных создаются через Query Interface. Query Interface
представляет из себя набор классов, специфичных для каждой СУБД.

\begin{lstlisting}[language=Ruby,caption=Запрос через ActiveRecord,label={lst:ar_sample_query}] 
@appntmentEvents = 
	DoctorUser.current.appointment_events.
	where('events.status <> ?', 'free').
	order('date_start DESC')
\end{lstlisting}

В листинге \ref{lst:ar_sample_query} представлен пример запроса, который
возвращает все врачебные приемы (appointment\_events) для пользователя доктор (DoctorUser), 
который на данный момент авторизован (current)
в системе, статус которых не свободно (where('events.status <> ?', 'free')) и
сортирует их в порядке, в котором первым отображается самый поздний врачебный прием
\\ (order("date\_start DESC")).

Для изменения состава атрибутов сущности в Ruby on Rails используется инструмент
мигрирования, который будет рассмотрен ниже.

\subsubsection{Готовая система валидации вводимых данных}
Валидации используются, чтобы быть уверенными, что только верно указанные данные
сохраняются в базу данных.

В Ruby on Rails валидация реализуется с помощью предопределенных валидационных
хелперов. Эти хелперы предоставляют общие правила валидации. Каждый раз, когда
валидация проваливается, сообщение об ошибке добавляется в коллекцию errors
объекта, и это сообщение связывается с аттрибутом, который подлежал валидации.

Для того чтобы использовать валидационной хелпер, его необходимо вызвать в
классе модели и через запятую указать те атрибуты класса, которые необходимо
проверить на правильность вводимых данных.

\subsubsection{Создание связей между сущностями}
Связи между моделями нужны для облегчения выполнения обычных операций с
объектами. Среда Ruby on Rails позволяет создавать связи типа один к одному,
один ко многим и многие ко многим. В рассмотренном выше примере получения всех
врачебных приемов доктора использовалась связь appointment\_events.

Для использования связей достаточно в классе сущности указать тип связи и класс
сущности с которой создается связь. В качестве примера приведем связь между
сущностями “Событие” и “Пользователь”, которая реализуется с целью определения
пользователя-создателя события.

\begin{lstlisting}[language=Ruby,caption=Связь на
стороне события,label={lst:ar_event_links}] 
class Event < ActiveRecord::Base
  # #{Организатор события} 
  belongs_to :user
end  
\end{lstlisting}

\begin{lstlisting}[language=Ruby,caption=Связь на
стороне события,label={lst:ar_user_links}]
class User < ActiveRecord::Base  
  # #{События для которых пациент является организатором}
  has_many :events
  # #{События в которых участвовал пациент}
  has_many :attendees_events, :through => :attendees, :source => :event
end  
\end{lstlisting}

Как видно из листинга кода, сущность ``Event'' связывается связью ``oдин ко
многим'' (belobgs\_to на стороне ``одного'' и has\_many на стороне ``многие'') с сущностью
``User''.

\subsubsection{Использование соглашений по конфигурации}
Сonvention over Сonfiguration\footnote{
	\url{http://en.wikipedia.org/wiki/Convention_over_configuration}
} — это принцип построения фреймворков и
библиотек, призванный сократить количество требуемой конфигурации без потери гибкости.
Обычно переводится как «соглашения по конфигурации».
В строгой форме этот принцип можно выразить так: аспект программной системы
нуждается в конфигурации тогда и только тогда, когда этот аспект не
удовлетворяет некоторой спецификации.
В качестве примера можно привести соглашение по именованию таблиц и классов -
при формировании названия таблицы имя класса пишется со строчной буквы с
добавлением окончанием множественного числа (англ. языка) “s”.

\subsubsection{Гибкость языка Ruby}
Основное назначение Ruby — создание простых и в то же время понятных программ,
где важна не скорость работы программы, а малое время разработки, понятность и
простота синтаксиса. Язык следует принципу «наименьшей неожиданности»\footnote{
	\url{http://ru.wikipedia.org/wiki/Ruby}
}: программа должна вести себя так, как ожидает программист.

\subsubsection{Вывод}
Исходя из требований к системе, оптимальной формой интерфейса системы будет
веб-сайт. На данный момент число технологий создания веб-сайтов достаточно
велико, у каждой есть свои плюсы и минусы. Исходя из требований к технологиям
оптимальным будет выбор фрэймворка Ruby On Rails.

Основные преимущества перед другими технологиями того же уровня:
\begin{enumerate}
  \item наличие большого числа библиотек, решающих большинство типовых задач при веб-разработке;
  \item большое сообщество;
  \item быстрое развитие;
  \item простота и удобство разработки. 
\end{enumerate}

\input{technologies/frontend}
\input{technologies/backend}